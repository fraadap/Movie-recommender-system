\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{enumitem}

\geometry{margin=1in}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\lstset{style=mystyle}

\title{\Huge Movie Recommender System\\[0.5cm] \Large Documentazione Tecnica Completa}
\author{Cloud Computing Project Team}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage

\section{Introduzione}
Questo documento fornisce una descrizione dettagliata ed esaustiva dell'architettura, dei componenti e dei servizi AWS utilizzati per implementare il sistema completo di raccomandazione film. Il sistema comprende backend serverless, gestione utenti, frontend web e algoritmi di machine learning per fornire raccomandazioni personalizzate.

\subsection{Obiettivi del Progetto}
Il Movie Recommender System è progettato per fornire un'esperienza completa di scoperta cinematografica attraverso:

\begin{itemize}[itemsep=0.5em]
  \item \textbf{Ricerca Semantica Avanzata}: Utilizzo di embedding neurali per permettere ricerche in linguaggio naturale su un dataset di 45.000+ film, superando le limitazioni della ricerca per keyword tradizionale.
  \item \textbf{Sistema di Raccomandazione Ibrido}: Implementazione di algoritmi content-based e collaborative filtering per suggerimenti personalizzati basati su preferenze utente e similarità comportamentali.
  \item \textbf{Gestione Utenti Completa}: Sistema di autenticazione, registrazione e gestione profili utente con tracciamento di preferenze, cronologia visualizzazioni e attività.
  \item \textbf{Interfaccia Web Moderna}: Frontend Vue.js responsive con design moderno e user experience ottimizzata per dispositivi desktop e mobile.
  \item \textbf{Architettura Scalabile}: Implementazione serverless su AWS per garantire scalabilità automatica e costi ottimizzati.
  \item \textbf{Monitoraggio e Analytics}: Sistema di logging e metriche per tracciare performance, utilizzo e comportamenti utente.
\end{itemize}

\subsection{Vincoli e Requisiti Tecnici}
Il progetto è stato sviluppato rispettando i seguenti vincoli:
\begin{itemize}
  \item \textbf{Budget limitato}: Implementazione con costi AWS contenuti (target: <50€/mese)
  \item \textbf{Tecnologie cloud-native}: Utilizzo esclusivo di servizi AWS serverless
  \item \textbf{Scalabilità}: Architettura in grado di gestire picchi di traffico senza pre-provisioning
  \item \textbf{Performance}: Tempi di risposta <2 secondi per ricerche e raccomandazioni
  \item \textbf{Sicurezza}: Implementazione di best practices per autenticazione e autorizzazione
\end{itemize}

\subsection{Panoramica dell'Architettura}
Il sistema è costruito su un'architettura serverless completamente cloud-native che comprende:

\begin{description}[style=nextline, leftmargin=0cm, itemsep=0.5em]
  \item[Backend Serverless] Tre funzioni AWS Lambda specializzate:
    \begin{itemize}
      \item \texttt{MovieSearchFunction}: Gestisce ricerca semantica e algoritmi di raccomandazione
      \item \texttt{MovieAuthFunction}: Gestisce autenticazione, registrazione e refresh token
      \item \texttt{MovieUserDataFunction}: Gestisce preferenze utente, cronologia e attività
    \end{itemize}
  
  \item[Data Layer] Sistema di storage distribuito:
    \begin{itemize}
      \item DynamoDB: 7 tabelle per metadati film, recensioni, utenti e dati comportamentali
      \item S3: Storage per embedding vettoriali (23MB, 45.000+ vettori a 384 dimensioni)
    \end{itemize}
  
  \item[API Gateway] Endpoint REST unificato con:
    \begin{itemize}
      \item 12 endpoint organizzati per funzionalità
      \item CORS abilitato per integrazione frontend
      \item Throttling e rate limiting configurabili
    \end{itemize}
  
  \item[Frontend Web] Applicazione Vue.js single-page con:
    \begin{itemize}
      \item Componenti modulari e riutilizzabili
      \item State management centralizzato (Vuex)
      \item Routing dinamico e lazy loading
      \item Design responsive e user experience ottimizzata
    \end{itemize}
  
  \item[Machine Learning Pipeline] Sistema di elaborazione embeddings:
    \begin{itemize}
      \item Sentence Transformers per generazione embedding
      \item Calcolo similarità coseno in-memory
      \item Algoritmi collaborative filtering basati su rating utenti
    \end{itemize}
  
  \item[Monitoring \& Observability] CloudWatch per:
    \begin{itemize}
      \item Logging centralizzato di tutte le funzioni Lambda
      \item Metriche performance e utilizzo risorse
      \item Allarmi automatici per errori e latenza
    \end{itemize}
\end{description}

\section{Architettura del Sistema}

\subsection{Diagramma Architetturale}
Il sistema segue un pattern di microservizi serverless con separazione delle responsabilità:

\begin{lstlisting}[language=bash, caption=Flusso di Comunicazione del Sistema]
Frontend (Vue.js) 
    ↓ HTTPS/REST
API Gateway 
    ↓ Lambda Proxy Integration
┌─────────────────┬─────────────────┬─────────────────┐
│ Search Lambda   │ Auth Lambda     │ UserData Lambda │
│ - /search       │ - /auth/login   │ - /user-data/*  │
│ - /content      │ - /auth/register│ - /user/*       │
│ - /collaborative│ - /auth/refresh │                 │
│ - /similar      │                 │                 │
└─────────────────┴─────────────────┴─────────────────┘
    ↓                    ↓                    ↓
┌─────────────────┬─────────────────┬─────────────────┐
│ DynamoDB        │ DynamoDB        │ DynamoDB        │
│ - Movies        │ - Users         │ - Favorites     │
│ - Reviews       │                 │ - Watched       │
│                 │                 │ - Preferences   │
│                 │                 │ - Activity      │
└─────────────────┴─────────────────┴─────────────────┘
    ↓
┌─────────────────┐
│ S3 Bucket       │
│ - embeddings.jsonl │
└─────────────────┘
\end{lstlisting}

\section{Componenti e Struttura del Codice}
\subsection{Struttura del Repository}
Il repository del progetto è organizzato seguendo le best practices per progetti serverless:

\begin{lstlisting}[language=bash]
movie-recommender-system/
├── README.md                           # Documentazione principale
├── requirements.txt                    # Dipendenze Python
├── doc/                               # Documentazione completa
│   ├── README.md                      # Guida setup e API
│   ├── DEPLOYMENT_GUIDE.md            # Guida deployment AWS
│   ├── api.yaml                       # Specifica OpenAPI 3.0
│   ├── PROJECT_DOCUMENTATION.tex      # Documentazione tecnica
│   └── files.txt                      # Panoramica file progetto
├── initial_setup/                     # Script setup iniziale
│   ├── create_table.py                # Creazione tabelle DynamoDB
│   ├── data_processor.py              # Elaborazione dataset
│   ├── generate_embeddings.py         # Generazione embedding
│   ├── api_gateway_setup.py           # Setup API Gateway
│   └── config.py                      # Configurazioni setup
├── lambda_functions/                  # Funzioni Lambda
│   ├── search_lambda_router.py        # Router ricerca/raccomandazioni
│   ├── search_lambda.py               # Logica algoritmi ML
│   ├── MovieAuthFunction.py           # Gestione autenticazione
│   └── MovieUserDataFunction.py       # Gestione dati utente
├── utils/                             # Utilities condivise
│   ├── database.py                    # Helper DynamoDB
│   └── utils_function.py              # Funzioni utility
└── frontend/                          # Applicazione Vue.js
    ├── package.json                   # Dipendenze NPM
    ├── src/
    │   ├── App.vue                    # Componente principale
    │   ├── main.js                    # Entry point
    │   ├── components/                # Componenti UI
    │   ├── views/                     # Pagine applicazione
    │   ├── router/                    # Configurazione routing
    │   ├── store/                     # State management
    │   └── services/                  # Integrazione API
    └── README.md                      # Documentazione frontend
\end{lstlisting}

\subsection{Funzioni Lambda - Architettura Modulare}

\subsubsection{Search Lambda Function (\texttt{search\_lambda\_router.py})}
Questa funzione è il cuore del sistema di raccomandazione e gestisce quattro endpoint principali:

\begin{itemize}
  \item \texttt{POST /search}: Ricerca semantica basata su query testuali
  \item \texttt{POST /content}: Raccomandazioni content-based per film specifici
  \item \texttt{POST /collaborative}: Raccomandazioni collaborative per utenti
  \item \texttt{POST /similar}: Film simili basati su embedding
\end{itemize}

\begin{lstlisting}[language=Python, caption=Struttura Router Search Lambda]
def lambda_handler(event, context):
    try:
        # Parsing della richiesta API Gateway
        path = event.get('path', '')
        method = event.get('httpMethod', '')
        body = json.loads(event.get('body', '{}'))
        
        # Routing basato su path
        if path == '/search' and method == 'POST':
            return semantic_search(body)
        elif path == '/content' and method == 'POST':
            return content_based_recommendations(body)
        elif path == '/collaborative' and method == 'POST':
            return collaborative_filtering(body)
        elif path == '/similar' and method == 'POST':
            return similar_movies(body)
        else:
            return create_response(400, {'error': 'Endpoint not found'})
            
    except Exception as e:
        logger.error(f"Lambda error: {str(e)}")
        return create_response(500, {'error': 'Internal server error'})
\end{lstlisting}

\subsubsection{Auth Lambda Function (\texttt{MovieAuthFunction.py})}
Gestisce l'intero ciclo di vita dell'autenticazione utente:

\begin{itemize}
  \item \texttt{POST /auth/login}: Autenticazione utente con email/password
  \item \texttt{POST /auth/register}: Registrazione nuovo utente
  \item \texttt{POST /auth/refresh}: Refresh del token JWT
\end{itemize}

\begin{lstlisting}[language=Python, caption=Gestione Autenticazione]
def lambda_handler(event, context):
    path = event.get('path', '')
    method = event.get('httpMethod', '')
    
    try:
        if path == '/auth/login' and method == 'POST':
            return handle_login(event)
        elif path == '/auth/register' and method == 'POST':
            return handle_register(event)
        elif path == '/auth/refresh' and method == 'POST':
            return handle_refresh(event)
        
    except Exception as e:
        return create_error_response(500, str(e))

def handle_login(event):
    body = json.loads(event.get('body', '{}'))
    email = body.get('email')
    password = body.get('password')
    
    # Verifica credenziali in DynamoDB
    user = verify_user_credentials(email, password)
    if user:
        # Genera JWT token
        token = generate_jwt_token(user)
        return create_success_response({
            'token': token,
            'user': format_user_data(user)
        })
    else:
        return create_error_response(401, 'Invalid credentials')
\end{lstlisting}

\subsubsection{User Data Lambda Function (\texttt{MovieUserDataFunction.py})}
Gestisce tutti i dati comportamentali e le preferenze utente:

\begin{itemize}
  \item \texttt{GET/POST /user-data/favorites}: Gestione lista preferiti
  \item \texttt{GET/POST /user-data/reviews}: Gestione recensioni utente
  \item \texttt{GET /user/activity}: Cronologia attività utente
  \item \texttt{GET /user/account}: Informazioni account utente
\end{itemize}

\begin{lstlisting}[language=Python, caption=Gestione Dati Utente]
def lambda_handler(event, context):
    # Verifica token JWT per tutti gli endpoint
    auth_result = verify_jwt_token(event)
    if not auth_result['valid']:
        return create_error_response(401, 'Unauthorized')
    
    user_id = auth_result['user_id']
    path = event.get('path', '')
    method = event.get('httpMethod', '')
    
    if path == '/user-data/favorites':
        if method == 'GET':
            return get_user_favorites(user_id)
        elif method == 'POST':
            return add_to_favorites(user_id, event)
    elif path == '/user-data/reviews':
        if method == 'GET':
            return get_user_reviews(user_id)
        elif method == 'POST':
            return add_user_review(user_id, event)
    # Altri endpoint...
\end{lstlisting}

\subsection{Sistema di Database - Schema DynamoDB}

Il sistema utilizza 7 tabelle DynamoDB ottimizzate per diversi pattern di accesso:

\subsubsection{Tabella Movies}
\begin{lstlisting}[language=JSON, caption=Schema Tabella Movies]
{
  "TableName": "Movies",
  "KeySchema": [{"AttributeName": "movie_id", "KeyType": "HASH"}],
  "Attributes": {
    "movie_id": "String",           # ID univoco film
    "title": "String",              # Titolo film
    "overview": "String",           # Trama
    "genres": "List<String>",       # Lista generi
    "release_date": "String",       # Data rilascio
    "vote_average": "Number",       # Voto medio
    "vote_count": "Number",         # Numero voti
    "popularity": "Number",         # Indice popolarità
    "cast": "List<String>",         # Cast principale
    "directors": "List<String>",    # Registi
    "runtime": "Number",            # Durata in minuti
    "budget": "Number",             # Budget produzione
    "revenue": "Number"             # Incassi
  }
}
\end{lstlisting}

\subsubsection{Tabella Reviews}
\begin{lstlisting}[language=JSON, caption=Schema Tabella Reviews]
{
  "TableName": "Reviews",
  "KeySchema": [
    {"AttributeName": "user_id", "KeyType": "HASH"},
    {"AttributeName": "movie_id", "KeyType": "RANGE"}
  ],
  "GlobalSecondaryIndexes": [{
    "IndexName": "MovieIndex",
    "KeySchema": [
      {"AttributeName": "movie_id", "KeyType": "HASH"},
      {"AttributeName": "user_id", "KeyType": "RANGE"}
    ]
  }],
  "Attributes": {
    "user_id": "String",            # ID utente
    "movie_id": "String",           # ID film
    "rating": "Number",             # Valutazione (1-5)
    "timestamp": "Number"           # Timestamp Unix
  }
}
\end{lstlisting}

\subsubsection{Tabelle Gestione Utenti}
\begin{lstlisting}[language=JSON, caption=Schema Tabelle Utente]
// MovieRecommender_Users
{
  "user_id": "String",              # ID univoco utente
  "email": "String",                # Email (univoca)
  "password_hash": "String",        # Hash password
  "name": "String",                 # Nome completo
  "created_at": "String",           # Data registrazione
  "last_login": "String"            # Ultimo accesso
}

// MovieRecommender_Favorites
{
  "user_id": "String",              # Partition key
  "movie_id": "String",             # Sort key
  "added_at": "String"              # Data aggiunta
}

// MovieRecommender_Activity
{
  "user_id": "String",              # Partition key
  "activity_id": "String",          # Sort key
  "activity_type": "String",        # Tipo attività
  "movie_id": "String",             # ID film coinvolto
  "timestamp": "String",            # Timestamp attività
  "details": "Map"                  # Dettagli aggiuntivi
}
\subsection{Frontend Architecture - Vue.js Application}

L'applicazione frontend è costruita con Vue.js 3 e segue l'architettura Component-Based con state management centralizzato.

\subsubsection{Struttura Componenti}
\begin{lstlisting}[language=JavaScript, caption=Struttura Frontend Vue.js]
src/
├── App.vue                     # Componente root
├── main.js                     # Entry point e configurazione
├── components/                 # Componenti riutilizzabili
│   ├── HeaderBar.vue          # Header con navigazione
│   ├── FooterBar.vue          # Footer informazioni
│   ├── Sidebar.vue            # Menu laterale
│   ├── MovieCard.vue          # Card film per liste
│   ├── MovieDetail.vue        # Dettaglio film completo
│   ├── LoadingSpinner.vue     # Indicatore caricamento
│   ├── NotificationSystem.vue # Sistema notifiche
│   └── ui/                    # Componenti UI base
├── views/                     # Pagine principali
│   ├── Home.vue              # Homepage con ricerca
│   ├── Search.vue            # Risultati ricerca
│   ├── MovieDetail.vue       # Pagina dettaglio film
│   ├── Login.vue             # Pagina login
│   ├── Register.vue          # Pagina registrazione
│   ├── Profile.vue           # Profilo utente
│   └── Favorites.vue         # Lista preferiti
├── store/                     # State management (Vuex)
│   ├── index.js              # Store principale
│   └── modules/
│       ├── auth.js           # Gestione autenticazione
│       ├── movies.js         # Gestione film e ricerche
│       └── ui.js             # Gestione UI state
├── services/                  # Integrazione API
│   ├── api.js                # Client API REST
│   └── syncService.js        # Sincronizzazione dati
├── router/                    # Routing configurazione
│   └── index.js              # Definizione routes
└── utils/                     # Utilities
    └── errorHandler.js        # Gestione errori
\end{lstlisting}

\subsubsection{State Management Pattern}
\begin{lstlisting}[language=JavaScript, caption=Vuex Store Structure]
// store/modules/auth.js
const state = {
  user: null,
  token: localStorage.getItem('authToken'),
  isAuthenticated: false,
  isLoading: false
}

const mutations = {
  SET_USER(state, user) {
    state.user = user
    state.isAuthenticated = !!user
  },
  SET_TOKEN(state, token) {
    state.token = token
    if (token) {
      localStorage.setItem('authToken', token)
    } else {
      localStorage.removeItem('authToken')
    }
  }
}

const actions = {
  async login({ commit }, credentials) {
    commit('SET_LOADING', true)
    try {
      const response = await api.post('/auth/login', credentials)
      commit('SET_TOKEN', response.data.token)
      commit('SET_USER', response.data.user)
      return { success: true }
    } catch (error) {
      return { success: false, error: error.response.data.error }
    } finally {
      commit('SET_LOADING', false)
    }
  }
}
\end{lstlisting}

\subsection{Algoritmi di Machine Learning}

\subsubsection{Generazione Embedding Semantici}
Il sistema utilizza il modello Sentence-BERT per convertire informazioni sui film in vettori a 384 dimensioni:

\begin{lstlisting}[language=Python, caption=Pipeline Generazione Embedding]
from sentence_transformers import SentenceTransformer

def generate_embeddings():
    # Carica modello pre-addestrato
    model = SentenceTransformer('sentence-transformers/all-MiniLM-L6-v2')
    
    # Combina metadati film in testo descrittivo
    def build_movie_text(movie):
        text_parts = [
            movie['title'],
            movie['overview'],
            ', '.join(movie['genres']),
            f"Cast: {', '.join(movie['cast'][:5])}",
            f"Director: {', '.join(movie['directors'])}"
        ]
        return ' '.join(filter(None, text_parts))
    
    # Genera embedding per tutti i film
    movie_texts = [build_movie_text(movie) for movie in movies]
    embeddings = model.encode(movie_texts, show_progress_bar=True)
    
    # Salva in formato JSONL per caricamento veloce
    with open('embeddings.jsonl', 'w') as f:
        for movie, embedding in zip(movies, embeddings):
            record = {
                'movie_id': movie['movie_id'],
                'embedding': embedding.tolist()
            }
            f.write(json.dumps(record) + '\n')
\end{lstlisting}

\subsubsection{Algoritmo Ricerca Semantica}
\begin{lstlisting}[language=Python, caption=Implementazione Ricerca Semantica]
def semantic_search(query, top_k=10):
    # Genera embedding per la query utente
    query_embedding = model.encode([query])[0]
    
    # Carica embedding pre-calcolati da S3
    embeddings_data = load_embeddings_from_s3()
    
    # Calcola similarità coseno con tutti i film
    similarities = []
    for item in embeddings_data:
        movie_embedding = np.array(item['embedding'])
        similarity = cosine_similarity(
            query_embedding.reshape(1, -1),
            movie_embedding.reshape(1, -1)
        )[0][0]
        similarities.append({
            'movie_id': item['movie_id'],
            'similarity': float(similarity)
        })
    
    # Ordina per similarità e restituisce top-k
    similarities.sort(key=lambda x: x['similarity'], reverse=True)
    top_movies = similarities[:top_k]
    
    # Arricchisce con metadati film da DynamoDB
    results = []
    for item in top_movies:
        movie = get_movie_by_id(item['movie_id'])
        if movie:
            movie['similarity_score'] = item['similarity']
            results.append(movie)
  \subsubsection{Content-Based Filtering}
\begin{lstlisting}[language=Python, caption=Algoritmo Content-Based]
def content_based_recommendations(movie_id, top_k=10):
    # Trova l'embedding del film di riferimento
    target_embedding = get_movie_embedding(movie_id)
    if not target_embedding:
        return []
    
    # Carica tutti gli embedding
    embeddings_data = load_embeddings_from_s3()
    
    # Calcola similarità con tutti gli altri film
    similarities = []
    for item in embeddings_data:
        if item['movie_id'] == movie_id:
            continue  # Esclude il film stesso
        
        similarity = cosine_similarity(target_embedding, item['embedding'])
        similarities.append({
            'movie_id': item['movie_id'],
            'similarity': float(similarity)
        })
    
    # Restituisce i film più simili
    similarities.sort(key=lambda x: x['similarity'], reverse=True)
    return enrich_with_metadata(similarities[:top_k])
\end{lstlisting}

\subsubsection{Collaborative Filtering}
\begin{lstlisting}[language=Python, caption=Algoritmo Collaborative Filtering]
def collaborative_filtering(user_id, top_k=10):
    # Ottiene le valutazioni dell'utente corrente
    user_ratings = get_user_ratings(user_id)
    if not user_ratings:
        return []
    
    # Trova utenti simili basandosi sui film in comune
    similar_users = find_similar_users(user_id, user_ratings)
    
    # Calcola raccomandazioni basate su utenti simili
    recommendations = {}
    for similar_user, similarity in similar_users:
        user_movies = get_user_ratings(similar_user['user_id'])
        
        for movie in user_movies:
            if movie['movie_id'] not in [r['movie_id'] for r in user_ratings]:
                # Film non ancora visto dall'utente corrente
                if movie['movie_id'] not in recommendations:
                    recommendations[movie['movie_id']] = 0
                
                # Pesa il rating per la similarità utente
                weighted_rating = movie['rating'] * similarity
                recommendations[movie['movie_id']] += weighted_rating
    
    # Ordina e restituisce le migliori raccomandazioni
    sorted_recs = sorted(recommendations.items(), 
                        key=lambda x: x[1], reverse=True)
    return enrich_with_metadata(sorted_recs[:top_k])

def find_similar_users(target_user_id, target_ratings):
    similar_users = []
    
    # Per ogni film valutato dall'utente target
    for rating in target_ratings:
        # Trova altri utenti che hanno valutato lo stesso film
        movie_ratings = get_ratings_for_movie(rating['movie_id'])
        
        for other_rating in movie_ratings:
            if other_rating['user_id'] != target_user_id:
                # Calcola similarità tra i due utenti
                similarity = calculate_user_similarity(
                    target_user_id, other_rating['user_id']
                )
                similar_users.append((other_rating, similarity))
    
    # Rimuove duplicati e ordina per similarità
    unique_users = {}
    for user, sim in similar_users:
        uid = user['user_id']
        if uid not in unique_users or unique_users[uid][1] < sim:
            unique_users[uid] = (user, sim)
    
    return sorted(unique_users.values(), 
                 key=lambda x: x[1], reverse=True)[:50]
\end{lstlisting}

\section{Implementazione Frontend}

\subsection{Architettura Vue.js}
Il frontend è implementato come Single Page Application (SPA) utilizzando Vue.js 3 con Composition API e TypeScript support.

\subsubsection{Routing e Navigation}
\begin{lstlisting}[language=JavaScript, caption=Vue Router Configuration]
// router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import { useStore } from 'vuex'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/search',
    name: 'Search',
    component: () => import('../views/Search.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/movie/:id',
    name: 'MovieDetail',
    component: () => import('../views/MovieDetail.vue'),
    props: true,
    meta: { requiresAuth: false }
  },
  {
    path: '/favorites',
    name: 'Favorites',
    component: () => import('../views/Favorites.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/profile',
    name: 'Profile',
    component: () => import('../views/Profile.vue'),
    meta: { requiresAuth: true }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

// Navigation Guard per autenticazione
router.beforeEach((to, from, next) => {
  const store = useStore()
  const isAuthenticated = store.getters['auth/isAuthenticated']
  
  if (to.meta.requiresAuth && !isAuthenticated) {
    next('/login')
  } else {
    next()
  }
})

export default router
\end{lstlisting}

\subsubsection{State Management con Vuex}
\begin{lstlisting}[language=JavaScript, caption=Movies Store Module]
// store/modules/movies.js
const state = {
  searchResults: [],
  recommendations: {
    content: [],
    collaborative: [],
    similar: []
  },
  currentMovie: null,
  searchQuery: '',
  isLoading: false,
  error: null
}

const mutations = {
  SET_SEARCH_RESULTS(state, results) {
    state.searchResults = results
  },
  SET_RECOMMENDATIONS(state, { type, data }) {
    state.recommendations[type] = data
  },
  SET_CURRENT_MOVIE(state, movie) {
    state.currentMovie = movie
  },
  SET_LOADING(state, loading) {
    state.isLoading = loading
  },
  SET_ERROR(state, error) {
    state.error = error
  }
}

const actions = {
  async searchMovies({ commit }, query) {
    commit('SET_LOADING', true)
    commit('SET_ERROR', null)
    
    try {
      const response = await api.post('/search', {
        query,
        top_k: 20
      })
      
      commit('SET_SEARCH_RESULTS', response.data.movies)
      commit('SET_SEARCH_QUERY', query)
      
      return { success: true, data: response.data }
    } catch (error) {
      const errorMessage = error.response?.data?.error || 'Search failed'
      commit('SET_ERROR', errorMessage)
      return { success: false, error: errorMessage }
    } finally {
      commit('SET_LOADING', false)
    }
  },

  async getRecommendations({ commit }, { type, movieId, userId }) {
    const endpoint = `/${type}`
    const payload = type === 'collaborative' 
      ? { user_id: userId, top_k: 10 }
      : { movie_id: movieId, top_k: 10 }
    
    try {
      const response = await api.post(endpoint, payload)
      commit('SET_RECOMMENDATIONS', { 
        type, 
        data: response.data.movies 
      })
      return response.data
    } catch (error) {
      commit('SET_ERROR', error.response?.data?.error)
      throw error
    }
  }
}

const getters = {
  hasSearchResults: state => state.searchResults.length > 0,
  getRecommendationsByType: state => type => state.recommendations[type],
  isSearching: state => state.isLoading,
  searchError: state => state.error
}

export default {
  namespaced: true,
  state,
  mutations,
  actions,
  getters
}
\end{lstlisting}
    denom = (np.linalg.norm(a_np) * np.linalg.norm(b_np))
    return float(np.dot(a_np, b_np) / denom) if denom != 0 else 0.0
\end{lstlisting}

Il Lambda handler supporta tre operazioni distinte:

\begin{enumerate}
  \item \texttt{search}: Ricerca semantica basata su query testuale
  \item \texttt{content}: Raccomandazioni basate su film già visti (content-based)
  \item \texttt{collaborative}: Raccomandazioni basate su utenti simili (collaborative)
\end{enumerate}

\section{Data Models e Storage}
\subsection{Schema DynamoDB per i Film}
La tabella \texttt{Movies} è strutturata per ottimizzare le query di ricerca e dettaglio. Lo schema include:

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Attributo} & \textbf{Tipo} & \textbf{Descrizione} \\
\midrule
movie\_id & String & Chiave primaria, identificativo univoco del film \\
title & String & Titolo del film \\
overview & String & Trama o sinossi del film \\
release\_year & Number & Anno di uscita del film \\
genres & List<String> & Lista dei generi del film \\
actors & List<String> & Lista dei principali attori (max 5) \\
directors & List<String> & Lista dei registi \\
vote\_average & Number & Valutazione media (scala 0-10) \\
vote\_count & Number & Numero di valutazioni ricevute \\
budget & Number & Budget di produzione (quando disponibile) \\
poster\_path & String & Percorso alla locandina (quando disponibile) \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Schema DynamoDB per le Recensioni}
La tabella \texttt{Reviews} è progettata per supportare efficientemente sia le query per utente che quelle per film (tramite GSI):

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Attributo} & \textbf{Tipo} & \textbf{Descrizione} \\
\midrule
user\_id & String & Chiave primaria (hash), ID utente \\
movie\_id & String & Chiave primaria (range), ID film \\
rating & Number & Valutazione (scala 0-5) \\
timestamp & Number & Timestamp della recensione (quando disponibile) \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Indice Secondario Globale}
Il GSI \texttt{MovieIndex} permette di interrogare rapidamente tutte le recensioni per un determinato film, fondamentale per il collaborative filtering:

\begin{center}
\begin{tabular}{lll}
\toprule
\textbf{Attributo} & \textbf{Tipo} & \textbf{Descrizione} \\
\midrule
movie\_id & String & Chiave hash per il GSI \\
user\_id & String & Chiave range per il GSI \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Storage degli Embedding su S3}
Gli embedding sono memorizzati in S3 in formato JSONL, con ogni riga che rappresenta un film. La scelta del formato JSONL permette:

\begin{itemize}
  \item Accesso sequenziale efficiente
  \item Caricamento incrementale (con S3 Select)
  \item Buona compressibilità
\end{itemize}

Gli embedding sono vettori di dimensione 384 (per \texttt{all-MiniLM-L6-v2}) che catturano le caratteristiche semantiche del film basandosi su titolo, trama, generi, cast e registi.

\section{Algoritmi di Raccomandazione}
\subsection{Ricerca Semantica}
La ricerca semantica implementa i seguenti passaggi:

\begin{enumerate}
  \item Riceve una query testuale dall'utente (es. "film di fantascienza con alieni")
  \item Trasforma la query in un embedding vettoriale usando lo stesso modello dei film
  \item Carica gli embedding di tutti i film da S3
  \item Calcola la similarità coseno tra l'embedding della query e quello di ogni film
  \item Ordina i film per similarità decrescente e restituisce i top-k risultati
\end{enumerate}

La formula della similarità coseno è:

\begin{equation}
\text{cosine\_similarity}(\vec{a}, \vec{b}) = \frac{\vec{a} \cdot \vec{b}}{\|\vec{a}\| \cdot \|\vec{b}\|}
\end{equation}

dove $\vec{a}$ e $\vec{b}$ sono gli embedding vettoriali, $\vec{a} \cdot \vec{b}$ è il prodotto scalare, e $\|\vec{a}\|$ è la norma euclidea del vettore.

\subsection{Content-Based Filtering}
Il content-based filtering implementa:

\begin{enumerate}
  \item Riceve una lista di film già visti dall'utente
  \item Recupera gli embedding corrispondenti
  \item Calcola un embedding medio che rappresenta i gusti dell'utente
  \item Calcola la similarità coseno tra questo embedding medio e tutti gli altri film
  \item Esclude i film già visti e restituisce i top-k film più simili
\end{enumerate}

L'embedding medio è calcolato come:

\begin{equation}
\vec{e}_{\text{avg}} = \frac{1}{n} \sum_{i=1}^{n} \vec{e}_i
\end{equation}

dove $\vec{e}_i$ sono gli embedding dei film già visti.

\subsection{Collaborative Filtering}
Il collaborative filtering implementa un approccio user-based:

\begin{enumerate}
  \item Recupera le valutazioni dell'utente corrente
  \item Per ogni film valutato, trova altri utenti che l'hanno valutato
  \item Calcola la similarità tra utenti basata sulle valutazioni comuni
  \item Identifica i "vicini più prossimi" (utenti con gusti simili)
  \item Per ogni film non visto dall'utente corrente, calcola un punteggio pesato basato sulle valutazioni dei vicini
  \item Restituisce i film con i punteggi più alti
\end{enumerate}

La formula per il punteggio predetto è:

\begin{equation}
\hat{r}_{u,i} = \frac{\sum_{v \in N(u)} \text{sim}(u,v) \cdot r_{v,i}}{\sum_{v \in N(u)} \text{sim}(u,v)}
\end{equation}

dove $\hat{r}_{u,i}$ è la valutazione prevista per l'utente $u$ sul film $i$, $N(u)$ è l'insieme dei vicini di $u$, $\text{sim}(u,v)$ è la similarità tra utenti, e $r_{v,i}$ è la valutazione data dall'utente $v$ al film $i$.

\section{Servizi AWS Utilizzati}
\subsection{AWS Lambda}
AWS Lambda esegue il codice serverless senza richiedere la gestione dell'infrastruttura. Nel nostro caso, viene utilizzato per implementare le operazioni di ricerca e raccomandazione. I vantaggi principali sono:

\begin{itemize}
  \item Pay-per-use: pagamento solo per il tempo di elaborazione effettivo
  \item Scalabilità automatica: gestione automatica dell'aumento di richieste
  \item Integrazione con altri servizi AWS: connessione nativa con API Gateway, DynamoDB, S3
\end{itemize}

Configurazione ottimale:
\begin{itemize}
  \item Memory: 512 MB (aumentabile se necessario per performance)
  \item Timeout: 30 secondi
  \item Concurrency: utilizzo del pool condiviso per iniziare
\end{itemize}

\subsection{Amazon DynamoDB}
DynamoDB è un database NoSQL serverless che offre prestazioni rapide e prevedibili con scalabilità automatica. Viene utilizzato per archiviare metadati dei film e recensioni utente.

Vantaggi:
\begin{itemize}
  \item Latenza costante indipendentemente dalla scala
  \item Scalabilità automatica
  \item Accesso tramite chiave primaria in O(1)
  \item Modalità on-demand per ottimizzare i costi in fase di sviluppo
\end{itemize}

\subsection{Amazon S3}
S3 viene utilizzato per archiviare gli embedding vettoriali generati per ogni film. La scelta di S3 è motivata da:

\begin{itemize}
  \item Costo di archiviazione molto basso
  \item Accesso rapido a oggetti specifici
  \item Durabilità estrema (99,999999999\%)
  \item Scalabilità illimitata
\end{itemize}

\subsection{Amazon API Gateway}
API Gateway espone l'endpoint RESTful che permette ai client di interagire con le funzioni Lambda. Configurazione:

\begin{itemize}
  \item Metodo POST all'endpoint /recommend
  \item Integrazione AWS\_PROXY con la Lambda
  \item Deployment in stage "prod"
\end{itemize}

\subsection{Amazon Cognito}
Cognito gestisce registrazione, login e autorizzazione degli utenti:

\begin{itemize}
  \item User Pools per l'autenticazione e memorizzazione degli utenti
  \item Identity Pools per l'accesso sicuro a risorse AWS
  \item Supporto per OAuth 2.0 e OpenID Connect
\end{itemize}

\subsection{Amazon CloudWatch}
CloudWatch monitora l'applicazione con:

\begin{itemize}
  \item Log per debugging e audit
  \item Metriche per performance e utilizzo
  \item Allarmi per notifiche proattive
\end{itemize}

\section{Processo di Deploy}
Il deployment su AWS segue questi passaggi sequenziali:

\subsection{Creazione delle Risorse di Base}
\begin{enumerate}
  \item Creazione di un bucket S3 per gli embedding:
\begin{lstlisting}[language=bash]
aws s3 mb s3://<EMBEDDINGS_BUCKET> --region <your-region>
\end{lstlisting}

  \item Creazione delle tabelle DynamoDB:
\begin{lstlisting}[language=bash]
python3 create_table.py
\end{lstlisting}
\end{enumerate}

\subsection{Ingestione dei Dati}
\begin{enumerate}
  \item Processamento dei metadati film e recensioni:
\begin{lstlisting}[language=bash]
python3 data_processor.py
\end{lstlisting}

  \item Generazione degli embedding e caricamento su S3:
\begin{lstlisting}[language=bash]
export EMBEDDINGS_BUCKET=<your-bucket-name>
python3 generate_embeddings.py
\end{lstlisting}
\end{enumerate}

\subsection{Configurazione della Lambda}
\begin{enumerate}
  \item Creazione di un package ZIP con tutte le dipendenze:
\begin{lstlisting}[language=bash]
mkdir package && cd package
pip install -r ../requirements.txt -t .
cp ../search_lambda.py .
zip -r ../search_lambda.zip .
\end{lstlisting}

  \item Creazione e configurazione della funzione Lambda:
\begin{lstlisting}[language=bash]
aws lambda create-function \
  --function-name MovieSearchFunction \
  --runtime python3.9 \
  --role arn:aws:iam::<ACCOUNT_ID>:role/<LAMBDA_EXEC_ROLE> \
  --handler search_lambda.lambda_handler \
  --timeout 30 \
  --memory-size 512 \
  --zip-file fileb://search_lambda.zip \
  --environment Variables='{
      "EMBEDDINGS_BUCKET":"<your-bucket-name>",
      "EMBEDDINGS_OUTPUT_FILE":"embeddings.jsonl",
      "EMBEDDING_MODEL":"sentence-transformers/all-MiniLM-L6-v2", 
      "DYNAMODB_TABLE":"Movies",
      "REVIEWS_TABLE":"Reviews"
  }'
\end{lstlisting}
\end{enumerate}

\subsection{Configurazione API Gateway}
\begin{enumerate}
  \item Creazione della REST API:
\begin{lstlisting}[language=bash]
aws apigateway create-rest-api --name "MovieRecommenderAPI"
\end{lstlisting}

  \item Recupero dell'ID della root resource e creazione della risorsa:
\begin{lstlisting}[language=bash]
aws apigateway get-resources --rest-api-id <api-id>
aws apigateway create-resource --rest-api-id <api-id> \
  --parent-id <root-id> --path-part recommend
\end{lstlisting}

  \item Impostazione del metodo POST e integrazione con Lambda:
\begin{lstlisting}[language=bash]
aws apigateway put-method --rest-api-id <api-id> \
  --resource-id <rec-id> --http-method POST \
  --authorization-type NONE

aws apigateway put-integration --rest-api-id <api-id> \
  --resource-id <rec-id> --http-method POST \
  --type AWS_PROXY --integration-http-method POST \
  --uri arn:aws:apigateway:<region>:lambda:path/2015-03-31/functions/arn:aws:lambda:<region>:<account-id>:function:MovieSearchFunction/invocations
\end{lstlisting}

  \item Configurazione delle autorizzazioni Lambda:
\begin{lstlisting}[language=bash]
aws lambda add-permission \
  --function-name MovieSearchFunction \
  --statement-id apigateway-access \
  --action lambda:InvokeFunction \
  --principal apigateway.amazonaws.com \
  --source-arn arn:aws:execute-api:<region>:<account-id>:<api-id>/*/POST/recommend
\end{lstlisting}

  \item Deployment dell'API:
\begin{lstlisting}[language=bash]
aws apigateway create-deployment --rest-api-id <api-id> \
  --stage-name prod
\end{lstlisting}
\end{enumerate}

\section{API Endpoints e Integrazione}

\subsection{Specifica OpenAPI 3.0}
Il sistema espone 12 endpoint REST organizzati in tre categorie funzionali:

\subsubsection{Search \& Recommendations Endpoints}
\begin{itemize}
  \item \texttt{POST /search}: Ricerca semantica con query in linguaggio naturale
  \item \texttt{POST /content}: Raccomandazioni content-based per un film specifico
  \item \texttt{POST /collaborative}: Raccomandazioni collaborative per un utente
  \item \texttt{POST /similar}: Film simili basati su embedding semantici
\end{itemize}

\subsubsection{Authentication Endpoints}
\begin{itemize}
  \item \texttt{POST /auth/login}: Autenticazione utente con email/password
  \item \texttt{POST /auth/register}: Registrazione nuovo utente
  \item \texttt{POST /auth/refresh}: Refresh token JWT
\end{itemize}

\subsubsection{User Data Management Endpoints}
\begin{itemize}
  \item \texttt{GET/POST /user-data/favorites}: Gestione lista preferiti
  \item \texttt{GET/POST /user-data/reviews}: Gestione recensioni utente
  \item \texttt{GET /user/activity}: Cronologia attività utente
  \item \texttt{GET /user/account}: Informazioni account utente
\end{itemize}

\subsection{Esempio di Integrazione API}
\begin{lstlisting}[language=JavaScript, caption=Client API Integration]
// services/api.js
import axios from 'axios'

const API_BASE_URL = process.env.VUE_APP_API_GATEWAY_URL

class MovieAPI {
  constructor() {
    this.client = axios.create({
      baseURL: API_BASE_URL,
      timeout: 30000,
      headers: {
        'Content-Type': 'application/json'
      }
    })

    // Interceptor per aggiungere token automaticamente
    this.client.interceptors.request.use(config => {
      const token = localStorage.getItem('authToken')
      if (token) {
        config.headers.Authorization = `Bearer ${token}`
      }
      return config
    })
  }

  // Ricerca semantica
  async searchMovies(query, topK = 10) {
    const response = await this.client.post('/search', {
      query,
      top_k: topK
    })
    return response.data
  }

  // Raccomandazioni content-based
  async getContentRecommendations(movieId, topK = 10) {
    const response = await this.client.post('/content', {
      movie_id: movieId,
      top_k: topK
    })
    return response.data
  }

  // Gestione preferiti
  async addToFavorites(movieId) {
    const response = await this.client.post('/user-data/favorites', {
      movie_id: movieId
    })
    return response.data
  }

  async getFavorites() {
    const response = await this.client.get('/user-data/favorites')
    return response.data
  }
}

export default new MovieAPI()
\end{lstlisting}

\section{Deployment e Infrastructure as Code}

\subsection{Architettura AWS Serverless}
Il sistema è completamente serverless e utilizza i seguenti servizi AWS:

\begin{description}
  \item[AWS Lambda] 3 funzioni per backend logic (512MB memory, 30s timeout)
  \item[Amazon DynamoDB] 7 tabelle con modalità pay-per-request
  \item[Amazon S3] 1 bucket per storage embedding (23MB)
  \item[Amazon API Gateway] 1 REST API con 12 endpoint
  \item[Amazon CloudWatch] Logging e monitoring automatico
\end{description}

\subsection{Configurazione Infrastructure}
\begin{lstlisting}[language=bash, caption=AWS Resources Configuration]
# DynamoDB Tables
Tables: 7 total
- Movies: ~45K items, ~28MB
- Reviews: ~26M items, ~518MB  
- MovieRecommender_Users: Variable size
- MovieRecommender_Favorites: Variable size
- MovieRecommender_Watched: Variable size
- MovieRecommender_Preferences: Variable size
- MovieRecommender_Activity: Variable size

# Lambda Functions
MovieSearchFunction:
  Runtime: python3.9
  Memory: 512MB
  Timeout: 30s
  Environment Variables: 5

MovieAuthFunction:
  Runtime: python3.9
  Memory: 256MB
  Timeout: 30s
  Environment Variables: 1

MovieUserDataFunction:
  Runtime: python3.9
  Memory: 256MB
  Timeout: 30s
  Environment Variables: 5

# S3 Storage
Bucket: movie-embeddings
- embeddings.jsonl (23MB)
- Access: Lambda functions only
\end{lstlisting}

\subsection{Deployment Automation}
Il deployment è completamente automatizzato attraverso script Python:

\begin{enumerate}
  \item \texttt{create\_table.py}: Creazione tabelle DynamoDB
  \item \texttt{data\_processor.py}: Caricamento dataset (2-3 ore)
  \item \texttt{generate\_embeddings.py}: Generazione embedding (30-45 min)
  \item \texttt{api\_gateway\_setup.py}: Configurazione API Gateway
\end{enumerate}

\section{Performance Analysis e Ottimizzazioni}

\subsection{Metriche di Performance}

\subsubsection{Latenza API}
\begin{itemize}
  \item \textbf{Ricerca Semantica}: 800ms - 2000ms (media: 1200ms)
  \item \textbf{Content-Based}: 600ms - 1500ms (media: 900ms)
  \item \textbf{Collaborative Filtering}: 1000ms - 3000ms (media: 1800ms)
  \item \textbf{Autenticazione}: 200ms - 500ms (media: 300ms)
  \item \textbf{User Data}: 150ms - 400ms (media: 250ms)
\end{itemize}

\subsubsection{Throughput}
\begin{itemize}
  \item \textbf{Concurrent Users}: 50-100 supportati senza degradazione
  \item \textbf{API Requests/sec}: 10-20 per endpoint search
  \item \textbf{DynamoDB RCU/WCU}: Auto-scaling attivo
\end{itemize}

\subsection{Ottimizzazioni Implementate}

\subsubsection{Caching Strategy}
\begin{lstlisting}[language=Python, caption=Lambda Memory Caching]
# Global variables per caching tra invocazioni
cached_embeddings = None
cached_model = None
cached_s3_client = None

def load_embeddings():
    global cached_embeddings
    if cached_embeddings is None:
        # Carica da S3 solo la prima volta
        cached_embeddings = download_from_s3()
    return cached_embeddings

def get_model():
    global cached_model
    if cached_model is None:
        cached_model = SentenceTransformer(MODEL_NAME)
    return cached_model
\end{lstlisting}

\subsubsection{Database Query Optimization}
\begin{itemize}
  \item \textbf{GSI Usage}: MovieIndex per query efficienti su movie\_id
  \item \textbf{Batch Operations}: BatchGetItem per recupero multiplo
  \item \textbf{Projection}: Only necessary attributes nelle query
  \item \textbf{Pagination}: Limit su scan operations estese
\end{itemize}

\subsection{Cost Analysis}
Costi mensili stimati per 1000 utenti attivi:

\begin{itemize}
  \item \textbf{Lambda}: \$8-12 (4M invocations, 2GB-sec compute)
  \item \textbf{DynamoDB}: \$15-25 (pay-per-request, read/write operations)
  \item \textbf{S3}: \$0.50 (23MB storage, minimal transfer)
  \item \textbf{API Gateway}: \$3-5 (1M API calls)
  \item \textbf{CloudWatch}: \$2-3 (logs and metrics)
  \item \textbf{Total}: \$28-45/month
\end{itemize}

\section{Testing e Quality Assurance}

\subsection{Testing Strategy}
\begin{itemize}
  \item \textbf{Unit Tests}: Algoritmi di raccomandazione isolati
  \item \textbf{Integration Tests}: API endpoints con mock data
  \item \textbf{End-to-End Tests}: Frontend + Backend full workflow
  \item \textbf{Load Tests}: Performance sotto carico
\end{itemize}

\subsection{Monitoring e Observability}
\begin{itemize}
  \item \textbf{CloudWatch Logs}: Centralized logging per tutte le Lambda
  \item \textbf{Custom Metrics}: Algoritm performance e accuracy
  \item \textbf{Alarms}: Error rates, latency thresholds
  \item \textbf{Dashboard}: Real-time system health monitoring
\end{itemize}

\section{Security e Compliance}

\subsection{Authentication \& Authorization}
\begin{itemize}
  \item \textbf{JWT Tokens}: Stateless authentication
  \item \textbf{Password Hashing}: bcrypt con salt
  \item \textbf{Token Refresh}: Automatic token renewal
  \item \textbf{Route Guards}: Protected endpoints validation
\end{itemize}

\subsection{Data Protection}
\begin{itemize}
  \item \textbf{HTTPS Only}: All API communications encrypted
  \item \textbf{IAM Roles}: Minimal privilege access
  \item \textbf{VPC Isolation}: DynamoDB in private subnets
  \item \textbf{Input Validation}: SQL injection and XSS prevention
\end{itemize}

\section{Future Enhancements}

\subsection{Scalability Improvements}
\begin{itemize}
  \item \textbf{ElastiCache}: Redis caching layer per embedding
  \item \textbf{DynamoDB DAX}: Sub-millisecond access times
  \item \textbf{Lambda@Edge}: Geographic content distribution
  \item \textbf{Multi-Region}: Global deployment per latency reduction
\end{itemize}

\subsection{Algorithm Enhancements}
\begin{itemize}
  \item \textbf{Deep Learning}: Neural collaborative filtering
  \item \textbf{Real-time Learning}: Online model updates
  \item \textbf{A/B Testing}: Algorithm performance comparison
  \item \textbf{Hybrid Models}: Ensemble recommendation methods
\end{itemize}

\section{Conclusioni}

Il Movie Recommender System rappresenta un'implementazione completa e moderna di un sistema di raccomandazione utilizzando tecnologie cloud-native AWS. Il progetto dimostra:

\subsection{Successi Tecnici}
\begin{itemize}
  \item \textbf{Architettura Scalabile}: Serverless design per auto-scaling
  \item \textbf{Performance Ottimale}: Sub-2s response times per la maggior parte delle operazioni
  \item \textbf{Cost-Effective}: Budget mensile <50€ per uso moderato
  \item \textbf{User Experience}: Frontend moderno e responsive
  \item \textbf{Algorithm Diversity}: Multiple recommendation strategies
\end{itemize}

\subsection{Lezioni Apprese}
\begin{itemize}
  \item \textbf{Cold Start}: Lambda warm-up strategies critiche per performance
  \item \textbf{Data Loading}: Embedding pre-computation essenziale per latency
  \item \textbf{State Management}: Frontend state management complesso ma necessario
  \item \textbf{Error Handling}: Comprehensive error handling cruciale per UX
\end{itemize}

\subsection{Impatto del Progetto}
Il sistema fornisce una base solida per:
\begin{itemize}
  \item Ricerca semantica avanzata in grandi dataset
  \item Raccomandazioni personalizzate multi-algoritmo
  \item Architettura serverless scalable e cost-effective
  \item Modern web application development patterns
\end{itemize}

Il progetto rappresenta un esempio completo di come le tecnologie cloud moderne possano essere utilizzate per implementare sistemi di machine learning sophisticati con budget limitato e performance enterprise-grade.

\end{document}